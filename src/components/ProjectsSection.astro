---
import { projectsConfig } from "../config/projects";
---

<section class="projects-section">
  <div class="projects-container">
    <h2 class="projects-title">Projects</h2>
    <div class="projects-carousel-wrapper">
      <div class="mask">
        <div
          role="region"
          aria-roledescription="carousel"
          class="coverflow-carousel"
          draggable="false"
          style="display:flex;position:relative;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;touch-action:pan-y"
        >
          <ul
            role="group"
            id="projects-carousel-ul"
            style="display:flex;position:relative;list-style-type:none;padding:0;margin:0;justify-content:flex-start;flex-direction:row;gap:0px;align-items:center;width:100%;height:100%;max-height:100%;max-width:100%;"
          >
            {projectsConfig.images.map((imageSrc, index) => (
              <li
                class="ticker-item"
                aria-hidden="false"
                aria-posinset={index + 1}
                aria-setsize={projectsConfig.images.length}
                style="flex-grow:0;flex-shrink:0;position:relative;height:fit-content;z-index:1000;transform:none"
              >
                <img
                  draggable="false"
                  src={imageSrc}
                  alt={`Project ${index + 1}`}
                  class="coverflow-item"
                  style="transform:perspective(500px)"
                />
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
    <!-- Project Description Area -->
    <div class="project-description-area" id="project-description-area">
      <div class="project-content">
        <h3 class="project-title" id="project-title">{projectsConfig.projects[0].title}</h3>
        <p class="project-description" id="project-description">
          {projectsConfig.projects[0].description}
        </p>
        <div class="project-technologies" id="project-technologies">
          {projectsConfig.projects[0].technologies.map((tech) => (
            <span class="technology-tag">{tech}</span>
          ))}
        </div>
        <div class="project-links" id="project-links">
          <a href={projectsConfig.projects[0].liveLink} class="project-link"
            >Live <span style="font-size: 1.2rem;">→</span></a
          >
          <a href={projectsConfig.projects[0].githubLink} class="project-link"
            >GitHub <span style="font-size: 1.2rem;">→</span></a
          >
        </div>
      </div>
    </div>
  </div>
</section>

<script type="application/json" id="projects-data" set:html={JSON.stringify(projectsConfig.projects)}></script>

<script>
  // Projects Carousel - Coverflow Effect (完全参考 carousel-demo.astro)
  (function initProjectsCarousel() {
    const carouselUl = document.getElementById("projects-carousel-ul");
    const carouselContainer = carouselUl?.parentElement; // .coverflow-carousel
    const items = carouselUl?.querySelectorAll(".ticker-item");
    const images = carouselUl?.querySelectorAll(".coverflow-item");

    if (!carouselUl || !carouselContainer || !items || !images) {
      console.error("Projects carousel elements not found");
      return;
    }

    // 项目数据（从配置文件读取）
    const projectsData = JSON.parse(document.getElementById('projects-data')?.textContent || '[]');

    // 更新项目介绍（带淡入淡出动画）
    function updateProjectDescription(projectIndex: number) {
      const project = projectsData[projectIndex];
      if (!project) return;

      const contentEl = document.querySelector(
        ".project-content"
      ) as HTMLElement;
      const titleEl = document.getElementById("project-title");
      const descriptionEl = document.getElementById("project-description");
      const technologiesEl = document.getElementById("project-technologies");
      const linksEl = document.getElementById("project-links");

      if (!contentEl) return;

      // 淡出动画
      contentEl.classList.remove("fade-in");
      contentEl.classList.add("fade-out");

      // 等待淡出完成后再更新内容
      setTimeout(() => {
        if (titleEl) titleEl.textContent = project.title;
        if (descriptionEl) descriptionEl.textContent = project.description;

        if (technologiesEl) {
          technologiesEl.innerHTML = project.technologies
            .map(
              (tech) => `<span class="technology-tag">${tech}</span>`
            )
            .join("");
        }

        if (linksEl) {
          linksEl.innerHTML = `
          <a href="${project.liveLink}" class="project-link"
            >Live <span style="font-size: 1.2rem;">→</span></a
          >
          <a href="${project.githubLink}" class="project-link"
            >GitHub <span style="font-size: 1.2rem;">→</span></a
          >
        `;
        }

        // 淡入动画
        requestAnimationFrame(() => {
          contentEl.classList.remove("fade-out");
          contentEl.classList.add("fade-in");
        });
      }, 200); // 等待淡出动画的一半时间
    }

    const itemWidth = 350; // SVG 图片宽度
    const gap = 0;
    const totalItems = items.length;
    const cloneCount = totalItems;

    // 创建克隆的 item（前面的克隆：整个列表）
    for (let i = 0; i < cloneCount; i++) {
      const originalItem = items[i];
      const clone = originalItem.cloneNode(true);
      clone.classList.add("clone-item");
      clone.setAttribute("data-clone-index", i);
      clone.setAttribute("data-original-index", i);
      clone.setAttribute("aria-hidden", "true");
      carouselUl.insertBefore(clone, items[0]);
    }

    // 创建克隆的 item（后面的克隆：整个列表）
    for (let i = 0; i < cloneCount; i++) {
      const originalItem = items[i];
      const clone = originalItem.cloneNode(true);
      clone.classList.add("clone-item");
      clone.setAttribute("data-clone-index", i);
      clone.setAttribute("data-original-index", i);
      clone.setAttribute("aria-hidden", "true");
      carouselUl.appendChild(clone);
    }

    // 重新获取所有 items（包括克隆的）
    const allItems = carouselUl.querySelectorAll(".ticker-item");
    const allImages = carouselUl.querySelectorAll(".coverflow-item");
    const totalVirtualItems = totalItems * 3;

    let currentX = 0;
    let isDragging = false;
    let startX = 0;
    let startScrollLeft = 0;
    let velocity = 0;
    let lastX = 0;
    let lastTime = 0;
    let animationFrameId: number | null = null;
    let dragDistance = 0;
    let clickedItemIndex: number | null = null;
    let autoPlayTimer: number | null = null;
    let isAutoPlaying = true;
    const autoPlayInterval = 4000;
    let lastProjectIndex = -1; // 记录上次显示的项目索引

    function getOffset(itemIndex: number, scrollX: number) {
      if (!carouselContainer) return 0;
      const containerCenter = carouselContainer.offsetWidth / 2;
      const itemStart = itemIndex * (itemWidth + gap);
      const itemCenterX = itemStart + scrollX + itemWidth / 2;
      return itemCenterX - containerCenter;
    }

    function lerp(
      input: number,
      inputRange: number[],
      outputRange: (number | string)[]
    ) {
      if (input <= inputRange[0]) return outputRange[0];
      if (input >= inputRange[inputRange.length - 1])
        return outputRange[outputRange.length - 1];

      for (let i = 0; i < inputRange.length - 1; i++) {
        if (input >= inputRange[i] && input <= inputRange[i + 1]) {
          const t =
            (input - inputRange[i]) / (inputRange[i + 1] - inputRange[i]);
          if (
            typeof outputRange[i] === "string" &&
            outputRange[i].includes("%")
          ) {
            const start = parseFloat(outputRange[i] as string);
            const end = parseFloat(outputRange[i + 1] as string);
            return start + (end - start) * t + "%";
          }
          return (
            (outputRange[i] as number) +
            ((outputRange[i + 1] as number) - (outputRange[i] as number)) * t
          );
        }
      }
      return outputRange[0];
    }

    function getTransformFromOffset(offset: number) {
      const rotateY = lerp(offset, [-200, 0, 200], [20, 0, -20]);
      const scale = lerp(offset, [-200, 0, 200], [0.7, 1, 0.7]);
      const x = lerp(
        offset,
        [-800, -200, 200, 800],
        ["100%", "0%", "0%", "-100%"]
      );
      const zIndex = Math.max(0, Math.round(1000 - Math.abs(offset)));
      return { rotateY, scale, x, zIndex };
    }

    function updateTransforms() {
      allItems.forEach((item, virtualIndex) => {
        const img = item.querySelector(".coverflow-item") as HTMLElement;
        if (!img) return;

        const offset = getOffset(virtualIndex, currentX);
        const { rotateY, scale, x, zIndex } = getTransformFromOffset(offset);

        (item as HTMLElement).style.zIndex = zIndex.toString();

        const xPx = x === "0%" ? 0 : (parseFloat(x as string) / 100) * itemWidth;

        img.style.transform = `perspective(500px) translateX(${xPx}px) rotateY(${rotateY}deg) scale(${scale})`;
      });
    }

    function getSnapPosition(virtualIndex: number) {
      if (!carouselContainer) return 0;
      const containerCenter = carouselContainer.offsetWidth / 2;
      const itemStart = virtualIndex * (itemWidth + gap);
      return containerCenter - itemStart - itemWidth / 2;
    }

    function checkLoopJump() {
      if (isDragging || animationFrameId) return;

      const singleSetWidth = totalItems * (itemWidth + gap);

      if (currentX > -singleSetWidth / 2) {
        currentX -= singleSetWidth;
        carouselUl.style.transition = "none";
        updateCarouselPosition();
        setTimeout(() => {
          carouselUl.style.transition = "";
        }, 0);
      }

      const maxScroll = -singleSetWidth * 1.5;
      if (currentX < maxScroll) {
        currentX += singleSetWidth;
        carouselUl.style.transition = "none";
        updateCarouselPosition();
        setTimeout(() => {
          carouselUl.style.transition = "";
        }, 0);
      }
    }

    function findNearestItem() {
      if (!carouselContainer) return totalItems;
      const containerCenter = carouselContainer.offsetWidth / 2;
      let nearestIndex = totalItems;
      let minDistance = Infinity;

      allItems.forEach((item, virtualIndex) => {
        const itemStart = virtualIndex * (itemWidth + gap);
        const itemCenterX = itemStart + currentX + itemWidth / 2;
        const distance = Math.abs(itemCenterX - containerCenter);
        if (distance < minDistance) {
          minDistance = distance;
          nearestIndex = virtualIndex;
        }
      });

      return nearestIndex;
    }

    // 从虚拟索引获取真实项目索引
    function getRealProjectIndex(virtualIndex: number): number {
      // 虚拟索引范围：
      // 0 ~ cloneCount-1: 前面的克隆
      // cloneCount ~ cloneCount+totalItems-1: 真实项目
      // cloneCount+totalItems ~ cloneCount*2+totalItems-1: 后面的克隆
      if (virtualIndex < cloneCount) {
        // 前面的克隆，映射到对应的真实项目
        return virtualIndex;
      } else if (virtualIndex < cloneCount + totalItems) {
        // 真实项目
        return virtualIndex - cloneCount;
      } else {
        // 后面的克隆，映射到对应的真实项目
        return virtualIndex - cloneCount - totalItems;
      }
    }

    // 更新项目介绍（基于当前最近的 item）
    function updateProjectDescriptionFromCarousel() {
      const nearestVirtualIndex = findNearestItem();
      const realIndex = getRealProjectIndex(nearestVirtualIndex);
      // 只在项目真正改变时才更新
      if (realIndex !== lastProjectIndex) {
        lastProjectIndex = realIndex;
        updateProjectDescription(realIndex);
      }
    }

    function goToItem(virtualIndex: number) {
      const snapX = getSnapPosition(virtualIndex);
      animateTo(snapX);
    }

    function nextItem() {
      const currentVirtualIndex = findNearestItem();
      const nextVirtualIndex = currentVirtualIndex + 1;
      goToItem(nextVirtualIndex);
    }

    function prevItem() {
      const currentVirtualIndex = findNearestItem();
      const prevVirtualIndex = currentVirtualIndex - 1;
      goToItem(prevVirtualIndex);
    }

    function startAutoPlay() {
      if (autoPlayTimer) return;
      autoPlayTimer = window.setInterval(() => {
        if (!isDragging && !animationFrameId && isAutoPlaying) {
          nextItem();
        }
      }, autoPlayInterval);
    }

    function stopAutoPlay() {
      if (autoPlayTimer) {
        clearInterval(autoPlayTimer);
        autoPlayTimer = null;
      }
    }

    function pauseAutoPlay() {
      stopAutoPlay();
      setTimeout(() => {
        if (isAutoPlaying) {
          startAutoPlay();
        }
      }, 5000);
    }

    function animateTo(targetX: number, duration = 450) {
      const startX = currentX;
      const startTime = performance.now();

      function animate(currentTime: number) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeOutCubic = 1 - Math.pow(1 - progress, 3);
        currentX = startX + (targetX - startX) * easeOutCubic;

        updateCarouselPosition();

        if (progress < 1) {
          animationFrameId = requestAnimationFrame(animate);
        } else {
          animationFrameId = null;
          checkLoopJump();
          // 动画结束后更新项目介绍
          updateProjectDescriptionFromCarousel();
        }
      }

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      animationFrameId = requestAnimationFrame(animate);
    }

    function updateCarouselPosition() {
      carouselUl.style.transform = `translateX(${currentX}px)`;
      updateTransforms();
      checkLoopJump();
    }

    carouselUl.addEventListener("mousedown", (e) => {
      const clickedElement = (e.target as HTMLElement).closest(".ticker-item");
      if (clickedElement) {
        clickedItemIndex = Array.from(allItems).indexOf(clickedElement);
      } else {
        clickedItemIndex = null;
      }

      isDragging = true;
      startX = e.pageX;
      startScrollLeft = currentX;
      lastX = e.pageX;
      lastTime = performance.now();
      velocity = 0;
      dragDistance = 0;
      carouselUl.style.cursor = "grabbing";

      pauseAutoPlay();

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    });

    carouselUl.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const now = performance.now();
      const deltaTime = now - lastTime;
      const deltaX = e.pageX - lastX;

      if (deltaTime > 0) {
        velocity = deltaX / deltaTime;
      }

      const x = e.pageX - startX;
      dragDistance = Math.abs(x);
      currentX = startScrollLeft + x;
      updateCarouselPosition();

      lastX = e.pageX;
      lastTime = now;
    });

    carouselUl.addEventListener("mouseup", () => {
      if (isDragging) {
        isDragging = false;
        carouselUl.style.cursor = "grab";

        if (dragDistance < 5 && clickedItemIndex !== null) {
          const offset = getOffset(clickedItemIndex, currentX);

          if (offset < -50) {
            prevItem();
          } else if (offset > 50) {
            nextItem();
          } else {
            goToItem(clickedItemIndex);
          }
            } else {
              const nearestIndex = findNearestItem();
              const snapX = getSnapPosition(nearestIndex);
              animateTo(snapX);
              // 拖拽结束后立即更新项目介绍
              setTimeout(() => {
                updateProjectDescriptionFromCarousel();
              }, 100);
            }

        dragDistance = 0;
        clickedItemIndex = null;

        pauseAutoPlay();
      }
    });

    carouselUl.addEventListener("mouseleave", () => {
      if (isDragging) {
        isDragging = false;
        carouselUl.style.cursor = "grab";
      }
    });

    carouselUl.addEventListener("touchstart", (e) => {
      isDragging = true;
      startX = e.touches[0].pageX;
      startScrollLeft = currentX;
      lastX = e.touches[0].pageX;
      lastTime = performance.now();
      velocity = 0;

      pauseAutoPlay();

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    });

    carouselUl.addEventListener("touchmove", (e) => {
      if (!isDragging) return;
      const now = performance.now();
      const deltaTime = now - lastTime;
      const deltaX = e.touches[0].pageX - lastX;

      if (deltaTime > 0) {
        velocity = deltaX / deltaTime;
      }

      const x = e.touches[0].pageX - startX;
      currentX = startScrollLeft + x;
      updateCarouselPosition();

      lastX = e.touches[0].pageX;
      lastTime = now;
    });

    carouselUl.addEventListener("touchend", () => {
      if (isDragging) {
        isDragging = false;

        const nearestIndex = findNearestItem();
        const snapX = getSnapPosition(nearestIndex);
        animateTo(snapX);
        // 触摸结束后立即更新项目介绍
        setTimeout(() => {
          updateProjectDescriptionFromCarousel();
        }, 100);

        pauseAutoPlay();
      }
    });

    carouselUl.style.cursor = "grab";

    allImages.forEach((img) => {
      (img as HTMLElement).style.cursor = "pointer";
    });

    if (carouselContainer) {
      const centerVirtualIndex = totalItems;
      currentX = getSnapPosition(centerVirtualIndex);
      updateCarouselPosition();
    }

    updateTransforms();

    // 初始化项目介绍（显示第一个项目）
    updateProjectDescription(0);

    startAutoPlay();
  })();
</script>

